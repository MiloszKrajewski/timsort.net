#region Licence

/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 
#endregion

#region Notes
//------------------------------------------------------------------------------
// Java implementation:
//
// A stable, adaptive, iterative mergesort that requires far fewer than
// n lg(n) comparisons when running on partially sorted arrays, while
// offering performance comparable to a traditional mergesort when run
// on random arrays.  Like all proper mergesorts, this sort is stable and
// runs O(n log n) time (worst case).  In the worst case, this sort requires
// temporary storage space for n/2 object references; in the best case,
// it requires only a small constant amount of space.
// 
// This implementation was adapted from Tim Peters's list sort for
// Python, which is described in detail here:
// http://svn.python.org/projects/python/trunk/Objects/listsort.txt
// 
// Tim's C code may be found here:
// http://svn.python.org/projects/python/trunk/Objects/listobject.c
// 
// The underlying techniques are described in this paper (and may have
// even earlier origins):
// 
// "Optimistic Sorting and Information Theoretic Complexity"
// Peter McIlroy
// SODA (Fourth Annual ACM-SIAM Symposium on Discrete Algorithms),
// pp 467-474, Austin, Texas, 25-27 January 1993.
// 
// While the API to this class consists solely of static methods, it is
// (privately) instantiable; a TimSort instance holds the state of an ongoing
// sort, assuming the input array is large enough to warrant the full-blown
// TimSort. Small arrays are sorted in place, using a binary insertion sort.
// 
// author: Josh Bloch
//------------------------------------------------------------------------------
// C# implementation:
//
// This implementation was adapted from Josh Bloch array sort for Java, 
// which has been found here:
// http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/TimSort.java?view=co
// 
// author: Milosz Krajewski
//------------------------------------------------------------------------------
#endregion

// !!! using System;
using System.Collections.Generic;
using System.Diagnostics;

// ReSharper disable CheckNamespace

namespace System.Linq
{

	#region class ByteArrayTimSort

	/// <summary>TimSort implementation for ByteArray.</summary>
	internal class ByteArrayTimSort: TimSortBase<Byte[], Byte>
	{
		/// <summary>
		/// Prevents a default instance of the ByteArrayTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private ByteArrayTimSort(Byte[] array)
			: base(array, array.Length)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(Byte[] array)
		{
			Sort(array, 0, array.Length);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(Byte[] array, int lo, int hi)
		{
			CheckRange(array.Length, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new ByteArrayTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(Byte[] array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Byte pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						Array.Copy(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(Byte[] array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				ArrayReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Byte key, Byte[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Byte key, Byte[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			Array.Copy(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						Array.Copy(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						Array.Copy(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			Array.Copy(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						Array.Copy(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						Array.Copy(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class ByteListTimSort

	/// <summary>TimSort implementation for ByteList.</summary>
	internal class ByteListTimSort: TimSortBase<List<Byte>, Byte>
	{
		/// <summary>
		/// Prevents a default instance of the ByteListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private ByteListTimSort(List<Byte> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(List<Byte> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(List<Byte> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new ByteListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(List<Byte> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Byte pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(List<Byte> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<Byte> src, int srcIndex, List<Byte> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(Byte[] src, int srcIndex, List<Byte> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<Byte> src, int srcIndex, Byte[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(List<Byte> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Byte key, List<Byte> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Byte key, List<Byte> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = ByteArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - ByteArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class ByteIListTimSort

	/// <summary>TimSort implementation for ByteIList.</summary>
	internal class ByteIListTimSort: TimSortBase<IList<Byte>, Byte>
	{
		/// <summary>
		/// Prevents a default instance of the ByteIListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private ByteIListTimSort(IList<Byte> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(IList<Byte> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(IList<Byte> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new ByteIListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(IList<Byte> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Byte pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(IList<Byte> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<Byte> src, int srcIndex, IList<Byte> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(Byte[] src, int srcIndex, IList<Byte> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<Byte> src, int srcIndex, Byte[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(IList<Byte> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Byte key, IList<Byte> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Byte key, IList<Byte> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = ByteArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - ByteArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class SByteArrayTimSort

	/// <summary>TimSort implementation for SByteArray.</summary>
	internal class SByteArrayTimSort: TimSortBase<SByte[], SByte>
	{
		/// <summary>
		/// Prevents a default instance of the SByteArrayTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private SByteArrayTimSort(SByte[] array)
			: base(array, array.Length)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(SByte[] array)
		{
			Sort(array, 0, array.Length);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(SByte[] array, int lo, int hi)
		{
			CheckRange(array.Length, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new SByteArrayTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(SByte[] array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				SByte pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						Array.Copy(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(SByte[] array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				ArrayReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(SByte key, SByte[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(SByte key, SByte[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			Array.Copy(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						Array.Copy(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						Array.Copy(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			Array.Copy(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						Array.Copy(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						Array.Copy(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class SByteListTimSort

	/// <summary>TimSort implementation for SByteList.</summary>
	internal class SByteListTimSort: TimSortBase<List<SByte>, SByte>
	{
		/// <summary>
		/// Prevents a default instance of the SByteListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private SByteListTimSort(List<SByte> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(List<SByte> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(List<SByte> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new SByteListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(List<SByte> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				SByte pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(List<SByte> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<SByte> src, int srcIndex, List<SByte> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(SByte[] src, int srcIndex, List<SByte> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<SByte> src, int srcIndex, SByte[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(List<SByte> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(SByte key, List<SByte> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(SByte key, List<SByte> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = SByteArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - SByteArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class SByteIListTimSort

	/// <summary>TimSort implementation for SByteIList.</summary>
	internal class SByteIListTimSort: TimSortBase<IList<SByte>, SByte>
	{
		/// <summary>
		/// Prevents a default instance of the SByteIListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private SByteIListTimSort(IList<SByte> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(IList<SByte> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(IList<SByte> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new SByteIListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(IList<SByte> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				SByte pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(IList<SByte> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<SByte> src, int srcIndex, IList<SByte> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(SByte[] src, int srcIndex, IList<SByte> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<SByte> src, int srcIndex, SByte[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(IList<SByte> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(SByte key, IList<SByte> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(SByte key, IList<SByte> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = SByteArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - SByteArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class Int16ArrayTimSort

	/// <summary>TimSort implementation for Int16Array.</summary>
	internal class Int16ArrayTimSort: TimSortBase<Int16[], Int16>
	{
		/// <summary>
		/// Prevents a default instance of the Int16ArrayTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private Int16ArrayTimSort(Int16[] array)
			: base(array, array.Length)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(Int16[] array)
		{
			Sort(array, 0, array.Length);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(Int16[] array, int lo, int hi)
		{
			CheckRange(array.Length, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new Int16ArrayTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(Int16[] array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Int16 pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						Array.Copy(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(Int16[] array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				ArrayReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Int16 key, Int16[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Int16 key, Int16[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			Array.Copy(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						Array.Copy(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						Array.Copy(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			Array.Copy(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						Array.Copy(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						Array.Copy(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class Int16ListTimSort

	/// <summary>TimSort implementation for Int16List.</summary>
	internal class Int16ListTimSort: TimSortBase<List<Int16>, Int16>
	{
		/// <summary>
		/// Prevents a default instance of the Int16ListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private Int16ListTimSort(List<Int16> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(List<Int16> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(List<Int16> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new Int16ListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(List<Int16> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Int16 pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(List<Int16> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<Int16> src, int srcIndex, List<Int16> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(Int16[] src, int srcIndex, List<Int16> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<Int16> src, int srcIndex, Int16[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(List<Int16> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Int16 key, List<Int16> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Int16 key, List<Int16> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = Int16ArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - Int16ArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class Int16IListTimSort

	/// <summary>TimSort implementation for Int16IList.</summary>
	internal class Int16IListTimSort: TimSortBase<IList<Int16>, Int16>
	{
		/// <summary>
		/// Prevents a default instance of the Int16IListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private Int16IListTimSort(IList<Int16> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(IList<Int16> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(IList<Int16> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new Int16IListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(IList<Int16> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Int16 pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(IList<Int16> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<Int16> src, int srcIndex, IList<Int16> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(Int16[] src, int srcIndex, IList<Int16> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<Int16> src, int srcIndex, Int16[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(IList<Int16> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Int16 key, IList<Int16> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Int16 key, IList<Int16> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = Int16ArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - Int16ArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class UInt16ArrayTimSort

	/// <summary>TimSort implementation for UInt16Array.</summary>
	internal class UInt16ArrayTimSort: TimSortBase<UInt16[], UInt16>
	{
		/// <summary>
		/// Prevents a default instance of the UInt16ArrayTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private UInt16ArrayTimSort(UInt16[] array)
			: base(array, array.Length)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(UInt16[] array)
		{
			Sort(array, 0, array.Length);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(UInt16[] array, int lo, int hi)
		{
			CheckRange(array.Length, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new UInt16ArrayTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(UInt16[] array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				UInt16 pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						Array.Copy(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(UInt16[] array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				ArrayReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(UInt16 key, UInt16[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(UInt16 key, UInt16[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			Array.Copy(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						Array.Copy(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						Array.Copy(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			Array.Copy(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						Array.Copy(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						Array.Copy(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class UInt16ListTimSort

	/// <summary>TimSort implementation for UInt16List.</summary>
	internal class UInt16ListTimSort: TimSortBase<List<UInt16>, UInt16>
	{
		/// <summary>
		/// Prevents a default instance of the UInt16ListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private UInt16ListTimSort(List<UInt16> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(List<UInt16> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(List<UInt16> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new UInt16ListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(List<UInt16> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				UInt16 pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(List<UInt16> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<UInt16> src, int srcIndex, List<UInt16> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(UInt16[] src, int srcIndex, List<UInt16> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<UInt16> src, int srcIndex, UInt16[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(List<UInt16> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(UInt16 key, List<UInt16> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(UInt16 key, List<UInt16> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = UInt16ArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - UInt16ArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class UInt16IListTimSort

	/// <summary>TimSort implementation for UInt16IList.</summary>
	internal class UInt16IListTimSort: TimSortBase<IList<UInt16>, UInt16>
	{
		/// <summary>
		/// Prevents a default instance of the UInt16IListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private UInt16IListTimSort(IList<UInt16> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(IList<UInt16> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(IList<UInt16> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new UInt16IListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(IList<UInt16> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				UInt16 pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(IList<UInt16> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<UInt16> src, int srcIndex, IList<UInt16> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(UInt16[] src, int srcIndex, IList<UInt16> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<UInt16> src, int srcIndex, UInt16[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(IList<UInt16> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(UInt16 key, IList<UInt16> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(UInt16 key, IList<UInt16> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = UInt16ArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - UInt16ArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class Int32ArrayTimSort

	/// <summary>TimSort implementation for Int32Array.</summary>
	internal class Int32ArrayTimSort: TimSortBase<Int32[], Int32>
	{
		/// <summary>
		/// Prevents a default instance of the Int32ArrayTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private Int32ArrayTimSort(Int32[] array)
			: base(array, array.Length)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(Int32[] array)
		{
			Sort(array, 0, array.Length);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(Int32[] array, int lo, int hi)
		{
			CheckRange(array.Length, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new Int32ArrayTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(Int32[] array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Int32 pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						Array.Copy(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(Int32[] array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				ArrayReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Int32 key, Int32[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Int32 key, Int32[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			Array.Copy(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						Array.Copy(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						Array.Copy(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			Array.Copy(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						Array.Copy(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						Array.Copy(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class Int32ListTimSort

	/// <summary>TimSort implementation for Int32List.</summary>
	internal class Int32ListTimSort: TimSortBase<List<Int32>, Int32>
	{
		/// <summary>
		/// Prevents a default instance of the Int32ListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private Int32ListTimSort(List<Int32> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(List<Int32> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(List<Int32> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new Int32ListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(List<Int32> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Int32 pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(List<Int32> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<Int32> src, int srcIndex, List<Int32> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(Int32[] src, int srcIndex, List<Int32> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<Int32> src, int srcIndex, Int32[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(List<Int32> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Int32 key, List<Int32> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Int32 key, List<Int32> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = Int32ArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - Int32ArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class Int32IListTimSort

	/// <summary>TimSort implementation for Int32IList.</summary>
	internal class Int32IListTimSort: TimSortBase<IList<Int32>, Int32>
	{
		/// <summary>
		/// Prevents a default instance of the Int32IListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private Int32IListTimSort(IList<Int32> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(IList<Int32> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(IList<Int32> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new Int32IListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(IList<Int32> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Int32 pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(IList<Int32> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<Int32> src, int srcIndex, IList<Int32> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(Int32[] src, int srcIndex, IList<Int32> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<Int32> src, int srcIndex, Int32[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(IList<Int32> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Int32 key, IList<Int32> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Int32 key, IList<Int32> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = Int32ArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - Int32ArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class UInt32ArrayTimSort

	/// <summary>TimSort implementation for UInt32Array.</summary>
	internal class UInt32ArrayTimSort: TimSortBase<UInt32[], UInt32>
	{
		/// <summary>
		/// Prevents a default instance of the UInt32ArrayTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private UInt32ArrayTimSort(UInt32[] array)
			: base(array, array.Length)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(UInt32[] array)
		{
			Sort(array, 0, array.Length);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(UInt32[] array, int lo, int hi)
		{
			CheckRange(array.Length, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new UInt32ArrayTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(UInt32[] array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				UInt32 pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						Array.Copy(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(UInt32[] array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				ArrayReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(UInt32 key, UInt32[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(UInt32 key, UInt32[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			Array.Copy(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						Array.Copy(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						Array.Copy(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			Array.Copy(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						Array.Copy(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						Array.Copy(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class UInt32ListTimSort

	/// <summary>TimSort implementation for UInt32List.</summary>
	internal class UInt32ListTimSort: TimSortBase<List<UInt32>, UInt32>
	{
		/// <summary>
		/// Prevents a default instance of the UInt32ListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private UInt32ListTimSort(List<UInt32> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(List<UInt32> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(List<UInt32> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new UInt32ListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(List<UInt32> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				UInt32 pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(List<UInt32> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<UInt32> src, int srcIndex, List<UInt32> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(UInt32[] src, int srcIndex, List<UInt32> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<UInt32> src, int srcIndex, UInt32[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(List<UInt32> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(UInt32 key, List<UInt32> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(UInt32 key, List<UInt32> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = UInt32ArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - UInt32ArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class UInt32IListTimSort

	/// <summary>TimSort implementation for UInt32IList.</summary>
	internal class UInt32IListTimSort: TimSortBase<IList<UInt32>, UInt32>
	{
		/// <summary>
		/// Prevents a default instance of the UInt32IListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private UInt32IListTimSort(IList<UInt32> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(IList<UInt32> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(IList<UInt32> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new UInt32IListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(IList<UInt32> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				UInt32 pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(IList<UInt32> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<UInt32> src, int srcIndex, IList<UInt32> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(UInt32[] src, int srcIndex, IList<UInt32> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<UInt32> src, int srcIndex, UInt32[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(IList<UInt32> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(UInt32 key, IList<UInt32> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(UInt32 key, IList<UInt32> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = UInt32ArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - UInt32ArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class Int64ArrayTimSort

	/// <summary>TimSort implementation for Int64Array.</summary>
	internal class Int64ArrayTimSort: TimSortBase<Int64[], Int64>
	{
		/// <summary>
		/// Prevents a default instance of the Int64ArrayTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private Int64ArrayTimSort(Int64[] array)
			: base(array, array.Length)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(Int64[] array)
		{
			Sort(array, 0, array.Length);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(Int64[] array, int lo, int hi)
		{
			CheckRange(array.Length, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new Int64ArrayTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(Int64[] array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Int64 pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						Array.Copy(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(Int64[] array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				ArrayReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Int64 key, Int64[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Int64 key, Int64[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			Array.Copy(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						Array.Copy(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						Array.Copy(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			Array.Copy(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						Array.Copy(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						Array.Copy(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class Int64ListTimSort

	/// <summary>TimSort implementation for Int64List.</summary>
	internal class Int64ListTimSort: TimSortBase<List<Int64>, Int64>
	{
		/// <summary>
		/// Prevents a default instance of the Int64ListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private Int64ListTimSort(List<Int64> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(List<Int64> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(List<Int64> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new Int64ListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(List<Int64> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Int64 pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(List<Int64> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<Int64> src, int srcIndex, List<Int64> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(Int64[] src, int srcIndex, List<Int64> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<Int64> src, int srcIndex, Int64[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(List<Int64> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Int64 key, List<Int64> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Int64 key, List<Int64> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = Int64ArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - Int64ArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class Int64IListTimSort

	/// <summary>TimSort implementation for Int64IList.</summary>
	internal class Int64IListTimSort: TimSortBase<IList<Int64>, Int64>
	{
		/// <summary>
		/// Prevents a default instance of the Int64IListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private Int64IListTimSort(IList<Int64> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(IList<Int64> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(IList<Int64> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new Int64IListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(IList<Int64> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Int64 pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(IList<Int64> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<Int64> src, int srcIndex, IList<Int64> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(Int64[] src, int srcIndex, IList<Int64> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<Int64> src, int srcIndex, Int64[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(IList<Int64> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Int64 key, IList<Int64> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Int64 key, IList<Int64> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = Int64ArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - Int64ArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class UInt64ArrayTimSort

	/// <summary>TimSort implementation for UInt64Array.</summary>
	internal class UInt64ArrayTimSort: TimSortBase<UInt64[], UInt64>
	{
		/// <summary>
		/// Prevents a default instance of the UInt64ArrayTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private UInt64ArrayTimSort(UInt64[] array)
			: base(array, array.Length)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(UInt64[] array)
		{
			Sort(array, 0, array.Length);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(UInt64[] array, int lo, int hi)
		{
			CheckRange(array.Length, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new UInt64ArrayTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(UInt64[] array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				UInt64 pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						Array.Copy(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(UInt64[] array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				ArrayReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(UInt64 key, UInt64[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(UInt64 key, UInt64[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			Array.Copy(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						Array.Copy(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						Array.Copy(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			Array.Copy(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						Array.Copy(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						Array.Copy(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class UInt64ListTimSort

	/// <summary>TimSort implementation for UInt64List.</summary>
	internal class UInt64ListTimSort: TimSortBase<List<UInt64>, UInt64>
	{
		/// <summary>
		/// Prevents a default instance of the UInt64ListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private UInt64ListTimSort(List<UInt64> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(List<UInt64> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(List<UInt64> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new UInt64ListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(List<UInt64> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				UInt64 pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(List<UInt64> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<UInt64> src, int srcIndex, List<UInt64> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(UInt64[] src, int srcIndex, List<UInt64> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<UInt64> src, int srcIndex, UInt64[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(List<UInt64> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(UInt64 key, List<UInt64> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(UInt64 key, List<UInt64> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = UInt64ArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - UInt64ArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class UInt64IListTimSort

	/// <summary>TimSort implementation for UInt64IList.</summary>
	internal class UInt64IListTimSort: TimSortBase<IList<UInt64>, UInt64>
	{
		/// <summary>
		/// Prevents a default instance of the UInt64IListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private UInt64IListTimSort(IList<UInt64> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(IList<UInt64> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(IList<UInt64> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new UInt64IListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(IList<UInt64> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				UInt64 pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(IList<UInt64> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<UInt64> src, int srcIndex, IList<UInt64> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(UInt64[] src, int srcIndex, IList<UInt64> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<UInt64> src, int srcIndex, UInt64[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(IList<UInt64> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(UInt64 key, IList<UInt64> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(UInt64 key, IList<UInt64> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = UInt64ArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - UInt64ArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class SingleArrayTimSort

	/// <summary>TimSort implementation for SingleArray.</summary>
	internal class SingleArrayTimSort: TimSortBase<Single[], Single>
	{
		/// <summary>
		/// Prevents a default instance of the SingleArrayTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private SingleArrayTimSort(Single[] array)
			: base(array, array.Length)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(Single[] array)
		{
			Sort(array, 0, array.Length);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(Single[] array, int lo, int hi)
		{
			CheckRange(array.Length, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new SingleArrayTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(Single[] array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Single pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						Array.Copy(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(Single[] array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				ArrayReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Single key, Single[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Single key, Single[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			Array.Copy(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						Array.Copy(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						Array.Copy(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			Array.Copy(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						Array.Copy(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						Array.Copy(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class SingleListTimSort

	/// <summary>TimSort implementation for SingleList.</summary>
	internal class SingleListTimSort: TimSortBase<List<Single>, Single>
	{
		/// <summary>
		/// Prevents a default instance of the SingleListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private SingleListTimSort(List<Single> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(List<Single> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(List<Single> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new SingleListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(List<Single> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Single pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(List<Single> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<Single> src, int srcIndex, List<Single> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(Single[] src, int srcIndex, List<Single> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<Single> src, int srcIndex, Single[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(List<Single> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Single key, List<Single> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Single key, List<Single> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = SingleArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - SingleArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class SingleIListTimSort

	/// <summary>TimSort implementation for SingleIList.</summary>
	internal class SingleIListTimSort: TimSortBase<IList<Single>, Single>
	{
		/// <summary>
		/// Prevents a default instance of the SingleIListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private SingleIListTimSort(IList<Single> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(IList<Single> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(IList<Single> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new SingleIListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(IList<Single> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Single pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(IList<Single> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<Single> src, int srcIndex, IList<Single> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(Single[] src, int srcIndex, IList<Single> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<Single> src, int srcIndex, Single[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(IList<Single> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Single key, IList<Single> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Single key, IList<Single> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = SingleArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - SingleArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class DoubleArrayTimSort

	/// <summary>TimSort implementation for DoubleArray.</summary>
	internal class DoubleArrayTimSort: TimSortBase<Double[], Double>
	{
		/// <summary>
		/// Prevents a default instance of the DoubleArrayTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private DoubleArrayTimSort(Double[] array)
			: base(array, array.Length)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(Double[] array)
		{
			Sort(array, 0, array.Length);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(Double[] array, int lo, int hi)
		{
			CheckRange(array.Length, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new DoubleArrayTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(Double[] array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Double pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						Array.Copy(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(Double[] array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				ArrayReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Double key, Double[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Double key, Double[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			Array.Copy(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						Array.Copy(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						Array.Copy(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			Array.Copy(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						Array.Copy(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						Array.Copy(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class DoubleListTimSort

	/// <summary>TimSort implementation for DoubleList.</summary>
	internal class DoubleListTimSort: TimSortBase<List<Double>, Double>
	{
		/// <summary>
		/// Prevents a default instance of the DoubleListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private DoubleListTimSort(List<Double> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(List<Double> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(List<Double> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new DoubleListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(List<Double> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Double pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(List<Double> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<Double> src, int srcIndex, List<Double> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(Double[] src, int srcIndex, List<Double> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<Double> src, int srcIndex, Double[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(List<Double> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Double key, List<Double> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Double key, List<Double> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = DoubleArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - DoubleArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class DoubleIListTimSort

	/// <summary>TimSort implementation for DoubleIList.</summary>
	internal class DoubleIListTimSort: TimSortBase<IList<Double>, Double>
	{
		/// <summary>
		/// Prevents a default instance of the DoubleIListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private DoubleIListTimSort(IList<Double> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(IList<Double> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(IList<Double> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new DoubleIListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(IList<Double> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Double pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(IList<Double> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<Double> src, int srcIndex, IList<Double> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(Double[] src, int srcIndex, IList<Double> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<Double> src, int srcIndex, Double[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(IList<Double> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Double key, IList<Double> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Double key, IList<Double> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = DoubleArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - DoubleArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class DecimalArrayTimSort

	/// <summary>TimSort implementation for DecimalArray.</summary>
	internal class DecimalArrayTimSort: TimSortBase<Decimal[], Decimal>
	{
		/// <summary>
		/// Prevents a default instance of the DecimalArrayTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private DecimalArrayTimSort(Decimal[] array)
			: base(array, array.Length)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(Decimal[] array)
		{
			Sort(array, 0, array.Length);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(Decimal[] array, int lo, int hi)
		{
			CheckRange(array.Length, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new DecimalArrayTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(Decimal[] array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Decimal pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						Array.Copy(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(Decimal[] array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				ArrayReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Decimal key, Decimal[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Decimal key, Decimal[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			Array.Copy(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						Array.Copy(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						Array.Copy(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			Array.Copy(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						Array.Copy(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						Array.Copy(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class DecimalListTimSort

	/// <summary>TimSort implementation for DecimalList.</summary>
	internal class DecimalListTimSort: TimSortBase<List<Decimal>, Decimal>
	{
		/// <summary>
		/// Prevents a default instance of the DecimalListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private DecimalListTimSort(List<Decimal> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(List<Decimal> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(List<Decimal> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new DecimalListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(List<Decimal> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Decimal pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(List<Decimal> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<Decimal> src, int srcIndex, List<Decimal> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(Decimal[] src, int srcIndex, List<Decimal> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<Decimal> src, int srcIndex, Decimal[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(List<Decimal> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Decimal key, List<Decimal> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Decimal key, List<Decimal> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = DecimalArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - DecimalArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class DecimalIListTimSort

	/// <summary>TimSort implementation for DecimalIList.</summary>
	internal class DecimalIListTimSort: TimSortBase<IList<Decimal>, Decimal>
	{
		/// <summary>
		/// Prevents a default instance of the DecimalIListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private DecimalIListTimSort(IList<Decimal> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(IList<Decimal> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(IList<Decimal> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new DecimalIListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(IList<Decimal> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Decimal pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(IList<Decimal> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<Decimal> src, int srcIndex, IList<Decimal> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(Decimal[] src, int srcIndex, IList<Decimal> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<Decimal> src, int srcIndex, Decimal[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(IList<Decimal> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Decimal key, IList<Decimal> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Decimal key, IList<Decimal> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = DecimalArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - DecimalArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class CharArrayTimSort

	/// <summary>TimSort implementation for CharArray.</summary>
	internal class CharArrayTimSort: TimSortBase<Char[], Char>
	{
		/// <summary>
		/// Prevents a default instance of the CharArrayTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private CharArrayTimSort(Char[] array)
			: base(array, array.Length)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(Char[] array)
		{
			Sort(array, 0, array.Length);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(Char[] array, int lo, int hi)
		{
			CheckRange(array.Length, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new CharArrayTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(Char[] array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Char pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						Array.Copy(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(Char[] array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				ArrayReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Char key, Char[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Char key, Char[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			Array.Copy(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						Array.Copy(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						Array.Copy(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			Array.Copy(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						Array.Copy(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						Array.Copy(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class CharListTimSort

	/// <summary>TimSort implementation for CharList.</summary>
	internal class CharListTimSort: TimSortBase<List<Char>, Char>
	{
		/// <summary>
		/// Prevents a default instance of the CharListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private CharListTimSort(List<Char> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(List<Char> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(List<Char> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new CharListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(List<Char> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Char pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(List<Char> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<Char> src, int srcIndex, List<Char> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(Char[] src, int srcIndex, List<Char> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<Char> src, int srcIndex, Char[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(List<Char> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Char key, List<Char> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Char key, List<Char> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = CharArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - CharArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class CharIListTimSort

	/// <summary>TimSort implementation for CharIList.</summary>
	internal class CharIListTimSort: TimSortBase<IList<Char>, Char>
	{
		/// <summary>
		/// Prevents a default instance of the CharIListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private CharIListTimSort(IList<Char> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(IList<Char> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(IList<Char> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new CharIListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(IList<Char> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				Char pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(IList<Char> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<Char> src, int srcIndex, IList<Char> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(Char[] src, int srcIndex, IList<Char> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<Char> src, int srcIndex, Char[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(IList<Char> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(Char key, IList<Char> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(Char key, IList<Char> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = CharArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - CharArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class DateTimeArrayTimSort

	/// <summary>TimSort implementation for DateTimeArray.</summary>
	internal class DateTimeArrayTimSort: TimSortBase<DateTime[], DateTime>
	{
		/// <summary>
		/// Prevents a default instance of the DateTimeArrayTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private DateTimeArrayTimSort(DateTime[] array)
			: base(array, array.Length)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(DateTime[] array)
		{
			Sort(array, 0, array.Length);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(DateTime[] array, int lo, int hi)
		{
			CheckRange(array.Length, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new DateTimeArrayTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(DateTime[] array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				DateTime pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						Array.Copy(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(DateTime[] array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				ArrayReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(DateTime key, DateTime[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(DateTime key, DateTime[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			Array.Copy(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						Array.Copy(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						Array.Copy(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			Array.Copy(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						Array.Copy(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						Array.Copy(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class DateTimeListTimSort

	/// <summary>TimSort implementation for DateTimeList.</summary>
	internal class DateTimeListTimSort: TimSortBase<List<DateTime>, DateTime>
	{
		/// <summary>
		/// Prevents a default instance of the DateTimeListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private DateTimeListTimSort(List<DateTime> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(List<DateTime> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(List<DateTime> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new DateTimeListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(List<DateTime> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				DateTime pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(List<DateTime> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<DateTime> src, int srcIndex, List<DateTime> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(DateTime[] src, int srcIndex, List<DateTime> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<DateTime> src, int srcIndex, DateTime[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(List<DateTime> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(DateTime key, List<DateTime> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(DateTime key, List<DateTime> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = DateTimeArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - DateTimeArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class DateTimeIListTimSort

	/// <summary>TimSort implementation for DateTimeIList.</summary>
	internal class DateTimeIListTimSort: TimSortBase<IList<DateTime>, DateTime>
	{
		/// <summary>
		/// Prevents a default instance of the DateTimeIListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private DateTimeIListTimSort(IList<DateTime> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(IList<DateTime> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(IList<DateTime> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new DateTimeIListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(IList<DateTime> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				DateTime pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(IList<DateTime> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<DateTime> src, int srcIndex, IList<DateTime> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(DateTime[] src, int srcIndex, IList<DateTime> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<DateTime> src, int srcIndex, DateTime[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(IList<DateTime> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(DateTime key, IList<DateTime> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(DateTime key, IList<DateTime> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = DateTimeArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - DateTimeArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class TimeSpanArrayTimSort

	/// <summary>TimSort implementation for TimeSpanArray.</summary>
	internal class TimeSpanArrayTimSort: TimSortBase<TimeSpan[], TimeSpan>
	{
		/// <summary>
		/// Prevents a default instance of the TimeSpanArrayTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private TimeSpanArrayTimSort(TimeSpan[] array)
			: base(array, array.Length)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(TimeSpan[] array)
		{
			Sort(array, 0, array.Length);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(TimeSpan[] array, int lo, int hi)
		{
			CheckRange(array.Length, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new TimeSpanArrayTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(TimeSpan[] array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				TimeSpan pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						Array.Copy(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(TimeSpan[] array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				ArrayReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(TimeSpan key, TimeSpan[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(TimeSpan key, TimeSpan[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			Array.Copy(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						Array.Copy(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						Array.Copy(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			Array.Copy(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						Array.Copy(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						Array.Copy(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class TimeSpanListTimSort

	/// <summary>TimSort implementation for TimeSpanList.</summary>
	internal class TimeSpanListTimSort: TimSortBase<List<TimeSpan>, TimeSpan>
	{
		/// <summary>
		/// Prevents a default instance of the TimeSpanListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private TimeSpanListTimSort(List<TimeSpan> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(List<TimeSpan> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(List<TimeSpan> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new TimeSpanListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(List<TimeSpan> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				TimeSpan pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(List<TimeSpan> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<TimeSpan> src, int srcIndex, List<TimeSpan> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(TimeSpan[] src, int srcIndex, List<TimeSpan> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<TimeSpan> src, int srcIndex, TimeSpan[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(List<TimeSpan> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(TimeSpan key, List<TimeSpan> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(TimeSpan key, List<TimeSpan> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = TimeSpanArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - TimeSpanArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class TimeSpanIListTimSort

	/// <summary>TimSort implementation for TimeSpanIList.</summary>
	internal class TimeSpanIListTimSort: TimSortBase<IList<TimeSpan>, TimeSpan>
	{
		/// <summary>
		/// Prevents a default instance of the TimeSpanIListTimSort class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private TimeSpanIListTimSort(IList<TimeSpan> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(IList<TimeSpan> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(IList<TimeSpan> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new TimeSpanIListTimSort(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(IList<TimeSpan> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				TimeSpan pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot < array[mid]) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(IList<TimeSpan> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++] < array[lo]) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi] < array[runHi - 1]) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi] >= array[runHi - 1]) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<TimeSpan> src, int srcIndex, IList<TimeSpan> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(TimeSpan[] src, int srcIndex, IList<TimeSpan> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<TimeSpan> src, int srcIndex, TimeSpan[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(IList<TimeSpan> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(TimeSpan key, IList<TimeSpan> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key > array[lo + hint]) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key > array[lo + hint + ofs]) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key <= array[lo + hint - ofs]) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key > array[lo + m]) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(TimeSpan key, IList<TimeSpan> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key < array[lo + hint]) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key < array[lo + hint - ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key >= array[lo + hint + ofs])
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key < array[lo + m])
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2] < mergeBuffer[cursor1]) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = TimeSpanArrayTimSort.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2] < array[cursor1]) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - TimeSpanArrayTimSort.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class AnyArrayTimSort<T>

	/// <summary>TimSort implementation for AnyArray.</summary>
	/// <typeparam name="T">Type of item.</typeparam>
	internal class AnyArrayTimSort<T>: TimSortBase<T[], T>
	{
		/// <summary>The comparator for this sort.</summary>
		private readonly Comparison<T> _comparer;

		/// <summary>
		/// Prevents a default instance of the AnyArrayTimSort&lt;T&gt; class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		/// <param name="comparer">The comparator to determine the order of the sort.</param>
		private AnyArrayTimSort(T[] array, Comparison<T> comparer)
			: base(array, array.Length)
		{
			_comparer = comparer;
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="comparer">Comparer.</param>
		public static void Sort(T[] array, Comparison<T> comparer)
		{
			Sort(array, 0, array.Length, comparer);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="comparer">The comparator to determine the order of the sort.</param>
		public static void Sort(T[] array, int lo, int hi, Comparison<T> comparer)
		{
			CheckRange(array.Length, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi, comparer);
				BinarySort(array, lo, hi, lo + initRunLength, comparer);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new AnyArrayTimSort<T>(array, comparer);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi, comparer);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen, comparer);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		/// <param name="comparer">The comparator to used for the sort.</param>
		private static void BinarySort(T[] array, int lo, int hi, int start, Comparison<T> comparer)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				T pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (comparer(pivot, array[mid]) < 0) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						Array.Copy(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <param name="comparer">the comparator to used for the sort.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(T[] array, int lo, int hi, Comparison<T> comparer)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (comparer(array[runHi++], array[lo]) < 0) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && comparer(array[runHi], array[runHi - 1]) < 0) runHi++;
				ArrayReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && comparer(array[runHi], array[runHi - 1]) >= 0) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			var comparer = _comparer;
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0, comparer);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1, comparer);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <param name="comparer">the comparator used to order the range, and to search.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(T key, T[] array, int lo, int length, int hint, Comparison<T> comparer)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (comparer(key, array[lo + hint]) > 0) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && comparer(key, array[lo + hint + ofs]) > 0) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && comparer(key, array[lo + hint - ofs]) <= 0) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (comparer(key, array[lo + m]) > 0) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <param name="comparer">the comparator used to order the range, and to search.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(T key, T[] array, int lo, int length, int hint, Comparison<T> comparer)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (comparer(key, array[lo + hint]) < 0) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && comparer(key, array[lo + hint - ofs]) < 0)
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && comparer(key, array[lo + hint + ofs]) >= 0)
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (comparer(key, array[lo + m]) < 0)
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			Array.Copy(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			var comparer = _comparer;  // Use local variables for performance
			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (comparer(array[cursor2], mergeBuffer[cursor1]) < 0) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0, comparer);
					if (count1 != 0)
					{
						Array.Copy(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0, comparer);
					if (count2 != 0)
					{
						Array.Copy(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			Array.Copy(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			var comparer = _comparer;  // Use local variables for performance
			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (comparer(tmp[cursor2], array[cursor1]) < 0) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1, comparer);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						Array.Copy(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1, comparer);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						Array.Copy(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class AnyListTimSort<T>

	/// <summary>TimSort implementation for AnyList.</summary>
	/// <typeparam name="T">Type of item.</typeparam>
	internal class AnyListTimSort<T>: TimSortBase<List<T>, T>
	{
		/// <summary>The comparator for this sort.</summary>
		private readonly Comparison<T> _comparer;

		/// <summary>
		/// Prevents a default instance of the AnyListTimSort&lt;T&gt; class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		/// <param name="comparer">The comparator to determine the order of the sort.</param>
		private AnyListTimSort(List<T> array, Comparison<T> comparer)
			: base(array, array.Count)
		{
			_comparer = comparer;
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="comparer">Comparer.</param>
		public static void Sort(List<T> array, Comparison<T> comparer)
		{
			Sort(array, 0, array.Count, comparer);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="comparer">The comparator to determine the order of the sort.</param>
		public static void Sort(List<T> array, int lo, int hi, Comparison<T> comparer)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi, comparer);
				BinarySort(array, lo, hi, lo + initRunLength, comparer);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new AnyListTimSort<T>(array, comparer);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi, comparer);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen, comparer);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		/// <param name="comparer">The comparator to used for the sort.</param>
		private static void BinarySort(List<T> array, int lo, int hi, int start, Comparison<T> comparer)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				T pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (comparer(pivot, array[mid]) < 0) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <param name="comparer">the comparator to used for the sort.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(List<T> array, int lo, int hi, Comparison<T> comparer)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (comparer(array[runHi++], array[lo]) < 0) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && comparer(array[runHi], array[runHi - 1]) < 0) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && comparer(array[runHi], array[runHi - 1]) >= 0) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<T> src, int srcIndex, List<T> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(T[] src, int srcIndex, List<T> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<T> src, int srcIndex, T[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(List<T> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			var comparer = _comparer;
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0, comparer);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1, comparer);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <param name="comparer">the comparator used to order the range, and to search.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(T key, List<T> array, int lo, int length, int hint, Comparison<T> comparer)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (comparer(key, array[lo + hint]) > 0) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && comparer(key, array[lo + hint + ofs]) > 0) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && comparer(key, array[lo + hint - ofs]) <= 0) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (comparer(key, array[lo + m]) > 0) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <param name="comparer">the comparator used to order the range, and to search.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(T key, List<T> array, int lo, int length, int hint, Comparison<T> comparer)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (comparer(key, array[lo + hint]) < 0) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && comparer(key, array[lo + hint - ofs]) < 0)
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && comparer(key, array[lo + hint + ofs]) >= 0)
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (comparer(key, array[lo + m]) < 0)
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			var comparer = _comparer;  // Use local variables for performance
			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (comparer(array[cursor2], mergeBuffer[cursor1]) < 0) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = AnyArrayTimSort<T>.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0, comparer);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0, comparer);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			var comparer = _comparer;  // Use local variables for performance
			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (comparer(tmp[cursor2], array[cursor1]) < 0) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1, comparer);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - AnyArrayTimSort<T>.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1, comparer);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class AnyIListTimSort<T>

	/// <summary>TimSort implementation for AnyIList.</summary>
	/// <typeparam name="T">Type of item.</typeparam>
	internal class AnyIListTimSort<T>: TimSortBase<IList<T>, T>
	{
		/// <summary>The comparator for this sort.</summary>
		private readonly Comparison<T> _comparer;

		/// <summary>
		/// Prevents a default instance of the AnyIListTimSort&lt;T&gt; class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		/// <param name="comparer">The comparator to determine the order of the sort.</param>
		private AnyIListTimSort(IList<T> array, Comparison<T> comparer)
			: base(array, array.Count)
		{
			_comparer = comparer;
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="comparer">Comparer.</param>
		public static void Sort(IList<T> array, Comparison<T> comparer)
		{
			Sort(array, 0, array.Count, comparer);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="comparer">The comparator to determine the order of the sort.</param>
		public static void Sort(IList<T> array, int lo, int hi, Comparison<T> comparer)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi, comparer);
				BinarySort(array, lo, hi, lo + initRunLength, comparer);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new AnyIListTimSort<T>(array, comparer);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi, comparer);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen, comparer);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		/// <param name="comparer">The comparator to used for the sort.</param>
		private static void BinarySort(IList<T> array, int lo, int hi, int start, Comparison<T> comparer)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				T pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (comparer(pivot, array[mid]) < 0) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <param name="comparer">the comparator to used for the sort.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(IList<T> array, int lo, int hi, Comparison<T> comparer)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (comparer(array[runHi++], array[lo]) < 0) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && comparer(array[runHi], array[runHi - 1]) < 0) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && comparer(array[runHi], array[runHi - 1]) >= 0) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<T> src, int srcIndex, IList<T> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(T[] src, int srcIndex, IList<T> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<T> src, int srcIndex, T[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(IList<T> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			var comparer = _comparer;
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0, comparer);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1, comparer);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <param name="comparer">the comparator used to order the range, and to search.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(T key, IList<T> array, int lo, int length, int hint, Comparison<T> comparer)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (comparer(key, array[lo + hint]) > 0) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && comparer(key, array[lo + hint + ofs]) > 0) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && comparer(key, array[lo + hint - ofs]) <= 0) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (comparer(key, array[lo + m]) > 0) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <param name="comparer">the comparator used to order the range, and to search.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(T key, IList<T> array, int lo, int length, int hint, Comparison<T> comparer)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (comparer(key, array[lo + hint]) < 0) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && comparer(key, array[lo + hint - ofs]) < 0)
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && comparer(key, array[lo + hint + ofs]) >= 0)
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (comparer(key, array[lo + m]) < 0)
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			var comparer = _comparer;  // Use local variables for performance
			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (comparer(array[cursor2], mergeBuffer[cursor1]) < 0) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = AnyArrayTimSort<T>.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0, comparer);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0, comparer);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			var comparer = _comparer;  // Use local variables for performance
			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (comparer(tmp[cursor2], array[cursor1]) < 0) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1, comparer);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - AnyArrayTimSort<T>.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1, comparer);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class ComparableArrayTimSort<T>

	/// <summary>TimSort implementation for ComparableArray.</summary>
	/// <typeparam name="T">Type of item.</typeparam>
	internal class ComparableArrayTimSort<T>: TimSortBase<T[], T> where T: IComparable<T>
	{
		/// <summary>
		/// Prevents a default instance of the ComparableArrayTimSort&lt;T&gt; class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private ComparableArrayTimSort(T[] array)
			: base(array, array.Length)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(T[] array)
		{
			Sort(array, 0, array.Length);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(T[] array, int lo, int hi)
		{
			CheckRange(array.Length, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new ComparableArrayTimSort<T>(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(T[] array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				T pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot.CompareTo(array[mid]) < 0) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						Array.Copy(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(T[] array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++].CompareTo(array[lo]) < 0) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi].CompareTo(array[runHi - 1]) < 0) runHi++;
				ArrayReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi].CompareTo(array[runHi - 1]) >= 0) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(T key, T[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key.CompareTo(array[lo + hint]) > 0) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key.CompareTo(array[lo + hint + ofs]) > 0) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key.CompareTo(array[lo + hint - ofs]) <= 0) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key.CompareTo(array[lo + m]) > 0) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(T key, T[] array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key.CompareTo(array[lo + hint]) < 0) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key.CompareTo(array[lo + hint - ofs]) < 0)
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key.CompareTo(array[lo + hint + ofs]) >= 0)
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key.CompareTo(array[lo + m]) < 0)
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			Array.Copy(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2].CompareTo(mergeBuffer[cursor1]) < 0) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						Array.Copy(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						Array.Copy(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				Array.Copy(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				Array.Copy(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			Array.Copy(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2].CompareTo(array[cursor1]) < 0) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						Array.Copy(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						Array.Copy(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				Array.Copy(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				Array.Copy(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class ComparableListTimSort<T>

	/// <summary>TimSort implementation for ComparableList.</summary>
	/// <typeparam name="T">Type of item.</typeparam>
	internal class ComparableListTimSort<T>: TimSortBase<List<T>, T> where T: IComparable<T>
	{
		/// <summary>
		/// Prevents a default instance of the ComparableListTimSort&lt;T&gt; class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private ComparableListTimSort(List<T> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(List<T> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(List<T> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new ComparableListTimSort<T>(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(List<T> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				T pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot.CompareTo(array[mid]) < 0) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(List<T> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++].CompareTo(array[lo]) < 0) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi].CompareTo(array[runHi - 1]) < 0) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi].CompareTo(array[runHi - 1]) >= 0) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<T> src, int srcIndex, List<T> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(T[] src, int srcIndex, List<T> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(List<T> src, int srcIndex, T[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(List<T> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(T key, List<T> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key.CompareTo(array[lo + hint]) > 0) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key.CompareTo(array[lo + hint + ofs]) > 0) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key.CompareTo(array[lo + hint - ofs]) <= 0) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key.CompareTo(array[lo + m]) > 0) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(T key, List<T> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key.CompareTo(array[lo + hint]) < 0) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key.CompareTo(array[lo + hint - ofs]) < 0)
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key.CompareTo(array[lo + hint + ofs]) >= 0)
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key.CompareTo(array[lo + m]) < 0)
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2].CompareTo(mergeBuffer[cursor1]) < 0) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = ComparableArrayTimSort<T>.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2].CompareTo(array[cursor1]) < 0) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - ComparableArrayTimSort<T>.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

	#region class ComparableIListTimSort<T>

	/// <summary>TimSort implementation for ComparableIList.</summary>
	/// <typeparam name="T">Type of item.</typeparam>
	internal class ComparableIListTimSort<T>: TimSortBase<IList<T>, T> where T: IComparable<T>
	{
		/// <summary>
		/// Prevents a default instance of the ComparableIListTimSort&lt;T&gt; class from being created.
		/// Creates a TimSort instance to maintain the state of an ongoing sort.
		/// </summary>
		/// <param name="array">The array to be sorted.</param>
		private ComparableIListTimSort(IList<T> array)
			: base(array, array.Count)
		{
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		public static void Sort(IList<T> array)
		{
			Sort(array, 0, array.Count);
		}

		/// <summary>Sorts the specified array.</summary>
		/// <param name="array">Array to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		public static void Sort(IList<T> array, int lo, int hi)
		{
			CheckRange(array.Count, lo, hi);

			int width = hi - lo;
			if (width < 2) return; // Arrays of size 0 and 1 are always sorted

			// If array is small, do a "mini-TimSort" with no merges
			if (width < MIN_MERGE)
			{
				int initRunLength = CountRunAndMakeAscending(array, lo, hi);
				BinarySort(array, lo, hi, lo + initRunLength);
				return;
			}

			// March over the array once, left to right, finding natural runs,
			// extending short natural runs to minRun elements, and merging runs
			// to maintain stack invariant.
			var sorter = new ComparableIListTimSort<T>(array);
			int minRun = GetMinimumRunLength(width);
			do
			{
				// Identify next run
				int runLen = CountRunAndMakeAscending(array, lo, hi);

				// If run is short, extend to min(minRun, nRemaining)
				if (runLen < minRun)
				{
					int force = width <= minRun ? width : minRun;
					BinarySort(array, lo, lo + force, lo + runLen);
					runLen = force;
				}

				// Push run onto pending-run stack, and maybe merge
				sorter.PushRun(lo, runLen);
				sorter.MergeCollapse();

				// Advance to find next run
				lo += runLen;
				width -= runLen;
			} while (width != 0);

			// Merge all remaining runs to complete sort
			Debug.Assert(lo == hi);
			sorter.MergeForceCollapse();
			Debug.Assert(sorter._stackSize == 1);
		}

		/// <summary>
		/// Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
		/// sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
		/// If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
		/// assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
		/// </summary>
		/// <param name="array">the array in which a range is to be sorted.</param>
		/// <param name="lo">the index of the first element in the range to be sorted.</param>
		/// <param name="hi">the index after the last element in the range to be sorted.</param>
		/// <param name="start">start the index of the first element in the range that is not already known to be sorted 
		/// (<c><![CDATA[lo <= start <= hi]]></c>)</param>
		private static void BinarySort(IList<T> array, int lo, int hi, int start)
		{
			Debug.Assert(lo <= start && start <= hi);

			if (start == lo) start++;

			for (/* nothing */; start < hi; start++)
			{
				T pivot = array[start];

				// Set left (and right) to the index where a[start] (pivot) belongs
				int left = lo;
				int right = start;
				Debug.Assert(left <= right);

				// Invariants:
				// * pivot >= all in [lo, left).
				// * pivot < all in [right, start).
				while (left < right)
				{
					int mid = (left + right) >> 1;
					if (pivot.CompareTo(array[mid]) < 0) // c(pivot, array[mid]) < 0
					{
						right = mid;
					}
					else
					{
						left = mid + 1;
					}
				}
				Debug.Assert(left == right);

				// The invariants still hold: pivot >= all in [lo, left) and
				// pivot < all in [left, start), so pivot belongs at left.  Note
				// that if there are elements equal to pivot, left points to the
				// first slot after them -- that's why this sort is stable.
				// Slide elements over to make room to make room for pivot.

				int n = start - left; // The number of elements to move

				// switch is just an optimization for copyRange in default case
				switch (n)
				{
					case 2:
						array[left + 2] = array[left + 1];
						array[left + 1] = array[left];
						break;
					case 1:
						array[left + 1] = array[left];
						break;
					default:
						IndexedCopyRange(array, left, array, left + 1, n);
						break;
				}
				array[left] = pivot;
			}
		}

		/// <summary>
		/// Returns the length of the run beginning at the specified position in
		/// the specified array and reverses the run if it is descending (ensuring
		/// that the run will always be ascending when the method returns).
		/// A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
		/// or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
		/// For its intended use in a stable mergesort, the strictness of the
		/// definition of "descending" is needed so that the call can safely
		/// reverse a descending sequence without violating stability.
		/// </summary>
		/// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
		/// <param name="lo">index of the first element in the run.</param>
		/// <param name="hi">index after the last element that may be contained in the run. It is required 
		/// that <c><![CDATA[lo < hi]]></c>.</param>
		/// <returns>the length of the run beginning at the specified position in the specified array</returns>
		private static int CountRunAndMakeAscending(IList<T> array, int lo, int hi)
		{
			Debug.Assert(lo < hi);
			int runHi = lo + 1;
			if (runHi == hi) return 1;

			// Find end of run, and reverse range if descending
			if (array[runHi++].CompareTo(array[lo]) < 0) // c(a[runHi++], a[lo]) < 0
			{
				// Descending
				while (runHi < hi && array[runHi].CompareTo(array[runHi - 1]) < 0) runHi++;
				IndexedReverseRange(array, lo, runHi);
			}
			else
			{
				// Ascending
				while (runHi < hi && array[runHi].CompareTo(array[runHi - 1]) >= 0) runHi++; // c(a[runHi], a[runHi - 1]) >= 0
			}

			return runHi - lo;
		}

		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<T> src, int srcIndex, IList<T> dst, int dstIndex, int length)
		{
			if (dst == src && dstIndex - srcIndex > 0) // copy forward to the same array => use reverse order
			{
				srcIndex += length - 1;
				dstIndex += length - 1;
				while (length-- > 0) dst[dstIndex--] = src[srcIndex--];
			}
			else // copy to different array or backwards => use natural order
			{
				while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
			}
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(T[] src, int srcIndex, IList<T> dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}
		
		/// <summary>Copies the range from one array to another.</summary>
		/// <param name="src">The source array.</param>
		/// <param name="srcIndex">Starting index in source array.</param>
		/// <param name="dst">The destination array.</param>
		/// <param name="dstIndex">Starting index in destination array.</param>
		/// <param name="length">Number of elements to be copied.</param>
		private static void IndexedCopyRange(IList<T> src, int srcIndex, T[] dst, int dstIndex, int length)
		{
			while (length-- > 0) dst[dstIndex++] = src[srcIndex++];
		}

		/// <summary>Reverse the specified range of the specified array.</summary>
		/// <param name="array">the array in which a range is to be reversed.</param>
		/// <param name="lo">the index of the first element in the range to be reversed.</param>
		/// <param name="hi">the index after the last element in the range to be reversed.</param>
		private static void IndexedReverseRange(IList<T> array, int lo, int hi)
		{
			hi--;
			while (lo < hi)
			{
				var t = array[lo];
				array[lo++] = array[hi];
				array[hi--] = t;
			}
		}

		/// <summary>
		/// Merges the two runs at stack indices i and i+1.  Run i must be the penultimate or antepenultimate run on the stack. 
		/// In other words, i must be equal to stackSize-2 or stackSize-3.
		/// </summary>
		/// <param name="runIndex">stack index of the first of the two runs to merge.</param>
		protected override void MergeAt(int runIndex)
		{
			Debug.Assert(_stackSize >= 2);
			Debug.Assert(runIndex >= 0);
			Debug.Assert(runIndex == _stackSize - 2 || runIndex == _stackSize - 3);
			
			int base1 = _runBase[runIndex];
			int len1 = _runLength[runIndex];
			int base2 = _runBase[runIndex + 1];
			int len2 = _runLength[runIndex + 1];
			Debug.Assert(len1 > 0 && len2 > 0);
			Debug.Assert(base1 + len1 == base2);

			// Record the length of the combined runs; if i is the 3rd-last
			// run now, also slide over the last run (which isn't involved
			// in this merge). The current run (i+1) goes away in any case.
			_runLength[runIndex] = len1 + len2;
			if (runIndex == _stackSize - 3)
			{
				_runBase[runIndex + 1] = _runBase[runIndex + 2];
				_runLength[runIndex + 1] = _runLength[runIndex + 2];
			}
			_stackSize--;

			// Find where the first element of run2 goes in run1. Prior elements
			// in run1 can be ignored (because they're already in place).
			int k = GallopRight(_array[base2], _array, base1, len1, 0);
			Debug.Assert(k >= 0);
			base1 += k;
			len1 -= k;
			if (len1 == 0) return;

			// Find where the last element of run1 goes in run2. Subsequent elements
			// in run2 can be ignored (because they're already in place).
			len2 = GallopLeft(_array[base1 + len1 - 1], _array, base2, len2, len2 - 1);
			Debug.Assert(len2 >= 0);
			if (len2 == 0) return;

			// Merge remaining runs, using tmp array with min(len1, len2) elements
			if (len1 <= len2)
				MergeLo(base1, len1, base2, len2);
			else
				MergeHi(base1, len1, base2, len2);
		}

		/// <summary>
		/// Locates the position at which to insert the specified key into the
		/// specified sorted range; if the range contains an element equal to key,
		/// returns the index of the leftmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
		/// is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
		/// first k elements of a should precede key, and the last n - k should follow it.</returns>
		internal static int GallopLeft(T key, IList<T> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);
			int lastOfs = 0;
			int ofs = 1;

			if (key.CompareTo(array[lo + hint]) > 0) // comparer(key, array[lo + hint]) > 0
			{
				// Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key.CompareTo(array[lo + hint + ofs]) > 0) // comparer(key, array[lo + hint + ofs]) > 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				lastOfs += hint;
				ofs += hint;
			}
			else // if (key <= a[base + hint])
			{
				// Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key.CompareTo(array[lo + hint - ofs]) <= 0) // comparer(key, array[lo + hint - ofs]) <= 0
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0) // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to base
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
			// to the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key.CompareTo(array[lo + m]) > 0) // comparer(key, array[lo + m]) > 0
					lastOfs = m + 1; // a[base + m] < key
				else
					ofs = m; // key <= a[base + m]
			}
			Debug.Assert(lastOfs == ofs); // so a[base + ofs - 1] < key <= a[base + ofs]
			return ofs;
		}

		/// <summary>
		/// Like GallopLeft, except that if the range contains an element equal to
		/// key, GallopRight returns the index after the rightmost equal element.
		/// </summary>
		/// <param name="key">the key whose insertion point to search for.</param>
		/// <param name="array">the array in which to search.</param>
		/// <param name="lo">the index of the first element in the range.</param>
		/// <param name="length">the length of the range; must be &gt; 0.</param>
		/// <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
		/// the faster this method will run.</param>
		/// <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
		internal static int GallopRight(T key, IList<T> array, int lo, int length, int hint)
		{
			Debug.Assert(length > 0 && hint >= 0 && hint < length);

			int ofs = 1;
			int lastOfs = 0;
			if (key.CompareTo(array[lo + hint]) < 0) // comparer(key, array[lo + hint]) < 0
			{
				// Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
				int maxOfs = hint + 1;
				while (ofs < maxOfs && key.CompareTo(array[lo + hint - ofs]) < 0)
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				int tmp = lastOfs;
				lastOfs = hint - ofs;
				ofs = hint - tmp;
			}
			else
			{
				// a[b + hint] <= key
				// Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
				int maxOfs = length - hint;
				while (ofs < maxOfs && key.CompareTo(array[lo + hint + ofs]) >= 0)
				{
					lastOfs = ofs;
					ofs = (ofs << 1) + 1;
					if (ofs <= 0)   // int overflow
						ofs = maxOfs;
				}
				if (ofs > maxOfs)
					ofs = maxOfs;

				// Make offsets relative to b
				lastOfs += hint;
				ofs += hint;
			}
			Debug.Assert(-1 <= lastOfs && lastOfs < ofs && ofs <= length);

			// Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
			// the right of lastOfs but no farther right than ofs.  Do a binary
			// search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
			lastOfs++;
			while (lastOfs < ofs)
			{
				int m = lastOfs + ((ofs - lastOfs) >> 1);

				if (key.CompareTo(array[lo + m]) < 0)
					ofs = m; // key < a[b + m]
				else
					lastOfs = m + 1; // a[b + m] <= key
			}

			Debug.Assert(lastOfs == ofs); // so a[b + ofs - 1] <= key < a[b + ofs]
			return ofs;
		}

		/// <summary>
		/// Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
		/// the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
		/// (a[base1 + len1-1]) must be greater than all elements of the second run.
		/// For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
		/// len1 &gt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeLo(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy first run into temp array
			var array = _array; // For performance
			var mergeBuffer = EnsureCapacity(len1);
			IndexedCopyRange(array, base1, mergeBuffer, 0, len1);

			int cursor1 = 0;       // Indexes into tmp array
			int cursor2 = base2;   // Indexes int a
			int dest = base1;      // Indexes int a

			// Move first element of second run and deal with degenerate cases
			array[dest++] = array[cursor2++];
			if (--len2 == 0)
			{
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
				return;
			}
			if (len1 == 1)
			{
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; // Last elt of run 1 to end of merge
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				/*
				 * Do the straightforward thing until (if ever) one run starts
				 * winning consistently.
				 */
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					if (array[cursor2].CompareTo(mergeBuffer[cursor1]) < 0) // c(array[cursor2], mergeBuffer[cursor1]) < 0
					{
						array[dest++] = array[cursor2++];
						count2++;
						count1 = 0;
						if (--len2 == 0)
							goto break_outer;
					}
					else
					{
						array[dest++] = mergeBuffer[cursor1++];
						count1++;
						count2 = 0;
						if (--len1 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 1 && len2 > 0);
					count1 = ComparableArrayTimSort<T>.GallopRight(array[cursor2], mergeBuffer, cursor1, len1, 0);
					if (count1 != 0)
					{
						IndexedCopyRange(mergeBuffer, cursor1, array, dest, count1);
						dest += count1;
						cursor1 += count1;
						len1 -= count1;
						if (len1 <= 1) // len1 == 1 || len1 == 0
							goto break_outer;
					}
					array[dest++] = array[cursor2++];
					if (--len2 == 0)
						goto break_outer;

					count2 = GallopLeft(mergeBuffer[cursor1], array, cursor2, len2, 0);
					if (count2 != 0)
					{
						IndexedCopyRange(array, cursor2, array, dest, count2);
						dest += count2;
						cursor2 += count2;
						len2 -= count2;
						if (len2 == 0)
							goto break_outer;
					}
					array[dest++] = mergeBuffer[cursor1++];
					if (--len1 == 1)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			}  // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len1 == 1)
			{
				Debug.Assert(len2 > 0);
				IndexedCopyRange(array, cursor2, array, dest, len2);
				array[dest + len2] = mergeBuffer[cursor1]; //  Last elt of run 1 to end of merge
			}
			else if (len1 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len2 == 0);
				Debug.Assert(len1 > 1);
				IndexedCopyRange(mergeBuffer, cursor1, array, dest, len1);
			}
		}

		/// <summary>
		/// Like mergeLo, except that this method should be called only if
		/// len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
		/// </summary>
		/// <param name="base1">index of first element in first run to be merged.</param>
		/// <param name="len1">length of first run to be merged (must be &gt; 0).</param>
		/// <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
		/// <param name="len2">length of second run to be merged (must be &gt; 0).</param>
		private void MergeHi(int base1, int len1, int base2, int len2)
		{
			Debug.Assert(len1 > 0 && len2 > 0 && base1 + len1 == base2);

			// Copy second run into temp array
			var array = _array; // For performance
			var tmp = EnsureCapacity(len2);
			IndexedCopyRange(array, base2, tmp, 0, len2);

			int cursor1 = base1 + len1 - 1;  // Indexes into a
			int cursor2 = len2 - 1;          // Indexes into tmp array
			int dest = base2 + len2 - 1;     // Indexes into a

			// Move last element of first run and deal with degenerate cases
			array[dest--] = array[cursor1--];
			if (--len1 == 0)
			{
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
				return;
			}
			if (len2 == 1)
			{
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];
				return;
			}

			int minGallop = _minGallop;

			while (true)
			{
				int count1 = 0; // Number of times in a row that first run won
				int count2 = 0; // Number of times in a row that second run won

				// Do the straightforward thing until (if ever) one run appears to win consistently.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					if (tmp[cursor2].CompareTo(array[cursor1]) < 0) // c(tmp[cursor2], a[cursor1]) < 0
					{
						array[dest--] = array[cursor1--];
						count1++;
						count2 = 0;
						if (--len1 == 0)
							goto break_outer;
					}
					else
					{
						array[dest--] = tmp[cursor2--];
						count2++;
						count1 = 0;
						if (--len2 == 1)
							goto break_outer;
					}
				} while ((count1 | count2) < minGallop);

				// One run is winning so consistently that galloping may be a
				// huge win. So try that, and continue galloping until (if ever)
				// neither run appears to be winning consistently anymore.
				do
				{
					Debug.Assert(len1 > 0 && len2 > 1);
					count1 = len1 - GallopRight(tmp[cursor2], array, base1, len1, len1 - 1);
					if (count1 != 0)
					{
						dest -= count1;
						cursor1 -= count1;
						len1 -= count1;
						IndexedCopyRange(array, cursor1 + 1, array, dest + 1, count1);
						if (len1 == 0)
							goto break_outer;
					}
					array[dest--] = tmp[cursor2--];
					if (--len2 == 1)
						goto break_outer;

					count2 = len2 - ComparableArrayTimSort<T>.GallopLeft(array[cursor1], tmp, 0, len2, len2 - 1);
					if (count2 != 0)
					{
						dest -= count2;
						cursor2 -= count2;
						len2 -= count2;
						IndexedCopyRange(tmp, cursor2 + 1, array, dest + 1, count2);
						if (len2 <= 1)  // len2 == 1 || len2 == 0
							goto break_outer;
					}
					array[dest--] = array[cursor1--];
					if (--len1 == 0)
						goto break_outer;
					minGallop--;
				} while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);

				if (minGallop < 0)
					minGallop = 0;
				minGallop += 2;  // Penalize for leaving gallop mode
			} // End of "outer" loop

			break_outer: // goto me! ;)

			_minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

			if (len2 == 1)
			{
				Debug.Assert(len1 > 0);
				dest -= len1;
				cursor1 -= len1;
				IndexedCopyRange(array, cursor1 + 1, array, dest + 1, len1);
				array[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
			}
			else if (len2 == 0)
			{
				throw new ArgumentException("Comparison method violates its general contract!");
			}
			else
			{
				Debug.Assert(len1 == 0);
				Debug.Assert(len2 > 0);
				IndexedCopyRange(tmp, 0, array, dest - (len2 - 1), len2);
			}
		}
	}
	
	#endregion

}

// ReSharper restore CheckNamespace

